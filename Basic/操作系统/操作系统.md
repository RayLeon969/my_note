# 第一章	绪论



## 一.什么是操作系统

  概念：操作系统是一种系统软件，是软，硬件资源的控制中心，它尽量以合理的有效的方法组织单个或多个用户以多任务方式共享计算机操作系统的各种资源。

- 计算机系统的软件构成

![image-20231116144451047](assets\image-20231116144451047.png)

- 操作系统作为特殊子程序

- 操作系统作为资源管理者

  - 针对不同资源的特点，资源管理器提供两种资源共享使用的方法：时分 和 空分

    - 时分：是指多个用户进程分时地使用该资源。时分又分为独占式和分时式

    - 空分：是针对存储资源而言的。存储资源的控件可以被多个用户进程共同以分割的方式占用

- 操作系统提供程序并发运行机制



## 二.操作系统发展史

1. 监督程序
   1. 批处理系统：设计一个常驻主存的程序。
   2. 作业：是用户在一次上机活动中要求计算机系统所做的一系列工作的集合。
   3. 监督程序的特点：单道性，顺序性，自动性
   4. 监督程序和操作系统的区别：监督系统不具有并发机制！
   5. 利用脱机I/O技术改善系统性能（卫星机）
2. 专用操作系统
   1. 多道批处理系统
      1. 特征：并发，共享
      2. 优点：提高了CPU利用率，内存和IO利用率，系统吞吐量
      3. 缺点：平均周转时间长无交互能力
   2. 分时系统
      1. 特征：并发，共享，交互，独立
   3. 实时系统
      1. 特征：并发，交互，独立，及时，可靠，过载保护



## 三.操作系统的特征（重点）

- **并发性（基本特征）**
  - **并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。相当于Cpu单核，多个线程运行在一个内核上面。**
  - **并行：并行是指“并排行走”或“同时实行或实施”。在操作系统中是指** **一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生)，相当于Cpu多核，多个任务同时运行在多个内核上面。**
  - **并发和并行的区别**
    - **并发是指多个事情在同一时间段内同时发生，而并行是指多个事情在同一时间点上同时发生**
    - **并发的多个任务之间式互相抢占资源的，而并行的多个任务之间并不互相抢占资源**
- 共享性（基本特征）
- 虚拟性
- 异步性



# 第二章	操作系统运行机制和用户界面



## 一 中断和异常

  当中断或异常发生时，运行用户模式程序的处理机会马上进入**内核运行**

  中断（外中断）的引入是为了开发处理机和通道之间的并行操作

  异常（内中断）表示处理机执行指令时本身出现算术溢出，这时可以中断当前的执行流程，转到相应的错误处理程序或**自陷处理程序**

- 中断和异常的区别

  - 中断与正在执行的指令无关，可以屏蔽

  - 异常与正在执行的指令有关，不可以屏蔽

- 中断屏蔽的两种方法
  - 软件实现
  - 硬件实现



## 二 中断/异常响应

- PS和PC寄存器
  - PS：处理机状态字，又称程序状态字，PS寄存器的值用于描述处理机的运行状态，主要包含处理机当前运行态，处理机优先级，屏蔽外中断与否等标志位
  - PC：程序计数器

- 中断/异常处理
  - 一般中断/异常处理流程

![image-20231116145035547](assets\image-20231116145035547.png)

- 处理流程
  - 中断/异常进入
  - 保存现场
  - 分析原因并转入中断/异常处理程序
  - 恢复现场



## 三 操作系统运行模式

- 操作系统的功能模块
  - 系统初始化模块
  - 进程管理模块
  - 存储管理模块
  - I/O设备管理模块
  - 文件管理模块

- 操作系统运行模式
  - 独立运行的内核模式
  - 内核嵌入用户进程运行模式
  - 微内核运行模式



## 四 系统调用

  系统调用是操作系统内核程序和用户态运行程序之间的接口。凡是与资源有关的操作（如分配主存，进行I/O操作及文件操作等）都必须通过某种方式向操作系统提出服务请求，并由操作系统代为完成。

  系统调用过程

![image-20231116145210968](assets\image-20231116145210968.png)



# 第三章	进程与处理机管理



## 一 进程描述

  在操作系统中，程序以**进程方式**使用系统资源，包括程序和数据所用的空间，系统外部设备，文件等程序运行所需的系统资源，并且以**分时共享**的方式使用处理机资源。

  进程的两种执行

- 顺序执行
  - 顺序性
  - 封闭性
  - 可再现性
- 并发执行
  - 资源分配动态性
  - 间断性
  - 失去封闭型
  - 不可再现性

  进程的特征：

- 动态
- 并发
- 独立
- 制约
- 异步
- 结构

进程和程序的关系：进程是动态的，程序是静态的，进程是暂时的，程序是永久的

进程包括：程序，数据，进程控制块

进程的定义：进程是支持程序执行的机制。可以理解为程序对数据或请求的处理过程

**我们把程序，数据，用户栈的集合称为进程映像**

**PCB(进程控制块)**:

- **进程标识信息**
  - 进程的标识
  - 进程的产生者标识
  - 进程所属的用户标识
- **处理机状态信息**
  - 用户可用的寄存器或通用寄存器
  - 控制和状态寄存器
- **进程控制信息**
  - 调度和状态信息
  - 进程间通信信息
  - 存储管理信息
  - 进程所用资源列表
  - 链信息



##  二 进程状态

​    进程状态变化模型：

- **运行状态**
- **就绪状态**
- **等待状态（又称阻塞态）**
- **创建状态**
- **结束状态**

​     **进程状态变化图**：

![image-20231116145350524](assets\image-20231116145350524.png)

  进程挂起

  当进程在主存中时，它就处于运行，就绪，或等待状态之一。但是，当进程处于等待状态时，进程所等待的事件并不能很快到来，所以进程在短时间内不能往下运行，它就没必要占着宝贵的主存空间。为了能使处于等待状态的进程释放主存空间，系统将其交换到辅存中，这是进程便处于挂起状态。



## 三 进程控制与调度

​     进程调度:

- 高级调度：又称作业调度，在支持批处理的系统中，新提交的作业排入批处理队列中。
- 中级调度：在实存方式存储管理系统中，中级调度选取在辅存中的进程占用物理主存，为占用处理机做好准备。
- 低级调度：低级调度决定处于就绪状态的哪个进程将获得处理机。

​    进程调度方式

- 非剥夺方式
  - 优点：系统开销小，简单
  - 缺点：实时性差
- 剥夺方式 
  - 优点：加快系统吞吐率，加速系统响应时间
  - 缺点：系统开销大

   

​     **==进程调度算法==**

​     *一些描述进程调度算法的概念：*

- *周转时间：指进程从创建到结束运行所经历的时间*
- *平均周转时间：指N个进程的周转时间平均值* 
- *等待时间：指进程处于等待处理机状态的时间之和*
- *平均等待时间：n个进程的等待时间的平均时间*
- *带权周转时间：周转时间/服务时间*   

   

- **先来先服务调度算法（FCFS）**

​       	**基本原则是按照进程进入就绪队列的先后次序进行选择。**

- **优先级调度算法**

  -  **按照进程的优先级高低来进行调度，使高优先级进程优先得到处理机的调度。可分为：**

    - **非剥夺的优先级调度算法**

    - **可剥夺的优先级调度算法**

- **时间片轮转调度算法 该算法属于剥夺调度算法**

​       	**采用此算法的系统，其进程就绪队列往往是按进程到达的时间来排序。**

​       	**T=N*q  T：响应时间  N：用户进程数  q：时间片大小**

- **短进程优先调度算法（SPF） 该算法属于非剥夺调度算法**

​       	**短进程优先调度算法从进程的就绪队列中挑选那些运行时间最短的进程进入主存运行。**

- **最短剩余时间优先调度算法  该算法属于剥夺调度算法**

​       	**最短剩余时间优先调度算法的基本思想是让“运行到任务完成时所需的运行时间最短”的进程优先得到处理。**

- **最高响应比优先调度算法  该算法时非剥夺调度算法**

​       	**优先级=（等待时间+要求的服务时间）/要求的服务时间**



##  四 线程的引入

​     在一个进程中可以包含多个可以并发执行的部分，这些可执行的部分就成为线程

​     线程和进程的区别：

- 进程要求操作系统为其分配一块独立的地址空间，而线程是共用一片地址空间



# 第四章	进程同步与通信 进程死锁



## 一 进程的同步和互斥

- 进程的同步：指为完成用户任务的伙伴进程之间，因为需要在某些位置上协调他们的工作次序而等待，传递信息所产生的制约关系
- 进程的互斥：指进程之间因相互竞争使用独占型资源所产生的制约关系



###   同步与临界段问题

​     几个概念：

- 临界资源：一次仅允许一个进程使用的资源
- 临界段：是指各进程必须互斥执行的那种程序段



###  解决临界段问题的硬件实现方法

- 屏蔽中断方法
- Test_and_Set指令
- Swap指令

  上述实现临界段的硬件方法一般都要求临界段相当短，如果临界段过长会影响中断的响应或者引起处理机在空操作上循环导致忙等待



### 信号量（PV操作）

  P,V是两条原语

  原语：原语是指完成某个功能且在物理上或逻辑上不能被分割，不能被中断执行的操作序列

  PV操作的使用方式结构：

​     P（mutex）

​       临界段

​     V（mutex）

​       非临界段其中mutex就是信号量

执行P操作时，信号量如果代表资源数，信号量就要-1

执行V操作时，就要+1



## 二 消息传递

  要实现进程间的通信，有两种基本方法：

- 共享存储
- 消息传递
  - 发送消息
  - 接收消息



## 三 **死锁**

  对资源不加限制地分配可能导致进程间由于竞争资源而相互制约以致无法继续运行，就是死锁

  

### 死锁产生的原因：

- 资源的竞争
- 进程推进顺序不当

  死锁定义：在一个进程集合中，若每个进程都在等待某些释放资源事件的发生，，而这些事件又必须由这个进程集合中的某些进程来产生，就称该进程集合处于死锁状态

  

### **死锁产生的四个必要条件**

- **互斥**
- **占有等待**
- **非剥夺**
- **循环等待**

  

### 设计无死锁系统通常采用两种途径

- **死锁防止**
  - **破坏死锁产生的四个必要条件之一**
- **死锁避免**
  - **银行家算法**
    - **安全状态定义：设系统中由n个进程，若存在一个序列（P1,P2..Pn）,使得Pi以后还需要的资源可以通过系统现有空闲资源加上所有Pj（j<i）已占有的资源来满足，则称此时这个系统处于安全状态，序列P1,P2..Pn成为安全序列。**



# 第五章	存储管理



## 一 连续空间分配

   单道连续分配

- 存储分配与空间保护方法

​    在没有操作系统的时期，整个主存空间由单个用户使用，随着监督系统的出现存储管理也随之出现了。当时的存储管理十分简单，仅将主存划分成操作系统空间和用户程序空间

- 覆盖

​    覆盖的基本思想是，由于程序运行时并非任何时候都要访问程序及数据的各个部分，因此可以把用户区域分成一个固定区域和一个或多个覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。

- 交换

​    交换的基本思想是，把处于等待状态的作业从主存移入辅存，这一过程称之为**换出**，把准备好竞争处理机运行的作业从辅存移入主存，这一过程称为**换入**。

  多道连续固定分区法

- 地址重定位

​     地址重定位是指将用户程序目标代码中相对于0地址开始的所有指令，数据地址变换成指令，数据所在的主存物理地址。

   主要的重定位方法分为两种：

- 静态重定位：即在操作系统将目标代码加载到主存中时，将目标代码所有地址域改为“原地址➕目标代码所在主存起始地址”。
- 动态重定位：由硬件地址转换机制实现，在执行访存指令时将“原地址➕目标代码所在主存起始地址”后进行访问。



## 二 不连续空间分配

   连续分配空间存在的许多存储碎片和空间管理较复杂的问题。

- 页式管理

​     在页式系统中，逻辑空间，物理空间均以相同长度为单位进行等分，逻辑空间所划分出的每个区域称为**页**或**页面**，物理空间所划分出的每个区域则称为**页帧**。

​     页表

​     由于逻辑地址和物理地址不一致，因此必须把每页第一个单元逻辑地址所对应的物理地址登记在一张称之为页表的表中。页表的的起始位置存放在进程PCB的位置信息中。

​     地址结构

​     在页式系统中，为了通过页表把逻辑地址转换成物理地址，必须把线性的逻辑地址分解成页号，页内位移，分别记为P,d，利用页号通过查页表得到页帧号f，再由页帧号f和页内位移d计算出线性的物理地址。

- P=逻辑地址/页大小
- d=逻辑地址-P✖️页大小

  就页式管理而言，内部碎片虽然存在，但是很少，可忽略不计，故被认为没有内部碎片。可用空间的管理很简单，但硬件地址转换开销比较大。

- 段式管理
- 段页式管理



## 三 虚拟存储管理

随着用户程序功能的增加，进程所需空间越来越大，进程空间很容易突破主存的大小，导致进程无法进行，这时候就需要更大的空间来让程序运行，如何做到呢？

我们可以将超过主存的大小的程序部分放入到辅存当中去，给用户一种超大主存的错觉，假设主存有2G，运行的程序有8G，辅存有50G，此时主存不能覆盖程序，就只能把程序多余的部分先放到辅存中去，随着程序的执行在把那部分取回来运行。

拿页式虚存管理实现来说，将程序的一部分页放到主存中，然后有页表项来记录对应的页在主存中还是辅存中，当程序访问的页不在主存中的时候，就会根据页表项的指引去辅存当中查找



## 四 页替换策略

1. FIFO策略：先来先出去
2. OPT策略：淘汰下次访问距离当前最远的那些页
3. LRU策略：淘汰上次使用距当前最远的页



# 操作系统中的一些特殊进程



## 僵尸进程

什么是僵尸进程？

在Linux系统中，任何一个子进程在调用exit（）函数结束运行之后，内核会释放该进程的所有资源，包括占用的内存和打开的文件等。

同时也会留下一个叫做僵尸进程（Zombie）的数据结构，Zombie中存储了该进程的进程号，退出码，退出状态，使用的CPU时间等信息。即僵尸进程是早已死亡的子进程，但在进程表中占了一个位置。

子进程还会向父进程发送SIGCHLD信号，父进程调用wait（）或者waitpid（）函数可以将僵尸进程释放。

父进程若是在没有释放僵尸进程就提前结束了，僵尸进程则会由init进程接管。

僵尸进程的危害：1.如果系统中存在很多僵尸进程，进程号就一直会被他们占用。2.有限的进程号耗尽会使得系统无法创建新的进程。



## 孤儿进程

什么是孤儿进程？

父进程退出，而它的一个或多个子进程还在运行，这些子进程将成为孤儿进程。

孤儿进程会被init进程收养

孤儿进程结束运行时，init进程完成回收工作而不会对系统造成危害。

孤儿进程和僵尸进程的区别：

1.孤儿进程是子进程并未运行结束，而父进程提前结束，这时孤儿进程会被init进程进行收养，而不会对系统造成危害。

2.僵尸进程是子进程结束，父进程没对子进程进行回收，使得子进程成为了系统中的僵尸进程，僵尸进程就会占用系统的进程号，对系统有危害。



## 守护进程

1. 什么是守护进程？

​	守护进程是运行在后台的一种特殊进程，独立于控制终端，并且周期性的执行某种任务或者等待处理某些发生的事件。

​	守护进程不需要用户的输入就能运行，可以提供某种服务。

​	守护进程一般在系统启动时就开启了，除非强制终止，否则直到系统关机都保持运行。

​	守护进程经常以超级用户的权限运行。

​	守护进程的父进程是init进程。

​	守护进程是非交互式程序，没有控制终端。

2. 进程和线程的区别？

​	总体区别： 进程是资源分配的基本单位，线程是CPU调度的基本单位（用工厂车间和生产线去讲解）

​	细分区别： 资源、调度、开销（创建和销毁的开销、上下文切换的开销）、通信方式

​	Linux中： Linux中内核调度的基本单位task_struct，内核线程和用户线程

3. 进程间的通信方式

​	管道（半双工、要求亲缘关系）

​	FIFO（半双工、不要求亲缘关系）

​	信号量（PV操作、互斥量，生产者-消费者问题）

​	信号

​	消息队列（无须考虑同步、有选择的接收消息）

​	共享内存（减少进程间的数据拷贝）

​	socket（不同机器间的进程通信）

4. 进程同步中的临界区有什么处理方法？

​	使用互斥量Mutex或synchronized关键字

5. 僵尸进程如何检测？

​	基础： top命令查看是否存在僵尸进程，ps -ef | grep defunct查看僵尸进程具体信息

​	进阶： kill命令杀死其父进程

​	高阶： 僵尸进程的形成、危害、如何避免

5. 线程启动的方法

​	创建的方法： 继承Thread类、重写Runnable接口、重写Callable接口

​	启动的方法： 只有start()

6. Linux进程管理的相关命令

​	top/htop命令、ps命令、lsof命令、kill命令

7. Java中哪些地方会发生OOM?一个进程有3个线程，如果一个线程抛出OOM，其他两个线程还能运行么?

​	JVM栈和本地方法栈动态扩展扩展时无法申请到足够的内存，会抛出OutOfMemoryException异常。

​	堆和方法区无法满足内存分配需求时，会抛出OutOfMemoryException异常。

​	一个线程OOM，其他线程仍然可以运行；主线程OOM，其他线程仍然可以运行。