动态规划（Dynamic Programming，简称DP）是一种算法设计思想，主要用于解决具有重叠子问题和最优子结构性质的问题。它通过将问题分解为更小的子问题，解决每个子问题一次，并将结果保存，以便下次相同的子问题出现时，可以直接使用之前的结果，而不是重新计算。这种优化避免了重复计算，提高了算法效率。

# 动态规划的核心思想

1. **重叠子问题**：问题可以分解为相同的子问题，并且这些子问题在解决过程中会被重复计算。
2. **最优子结构**：问题的最优解可以通过子问题的最优解组合得到。即大问题的解可以由小问题的解构造而成。
3. **状态转移方程**：通过已知的子问题的解来计算更大问题的解，也称为递推公式或转移方程。
4. **记忆化或表格法**：将每个子问题的解记录下来（记忆化递归或填表法），以避免重复计算。

# 动态规划的基本步骤

1. **定义状态**：找到问题的子问题，定义每个子问题的状态，即我们希望子问题所解决的子任务是什么。
2. **建立递推关系（状态转移方程）**：根据子问题的最优子结构，找到一个状态和其他状态之间的关系，通常是递归的形式。
3. **确定初始条件**：为最基本的子问题（通常是最小的子任务）设定初始值。
4. **填表或递归求解**：使用递归或迭代来计算每个子问题的解，并存储起来，最终得到原问题的解。

# 动态规划的两种实现方式

1. 自顶向下的记忆化递归

   ：

   - 类似递归的形式，但在递归过程中，使用一个表格记录每个子问题的解，避免重复计算。

2. 自底向上的迭代

   ：

   - 通过表格（数组、矩阵）从最简单的子问题开始，逐步计算每个更大的问题，最后得到问题的最终解。



# 优缺点

## 优点：

- 避免了递归带来的重复计算，提高了算法的效率。
- 动态规划可以将指数时间复杂度问题（如斐波那契数列递归解法）优化为多项式时间复杂度问题。

## 缺点：

- 需要较大的内存空间来存储子问题的解。
- 有时构建状态转移方程并不容易，需要深入理解问题的结构。

## 动态规划与贪心算法的区别：

- 动态规划关注全局最优解，通过求解所有子问题并记录下来；
- 贪心算法通常是通过每一步的局部最优来求解问题，无法保证全局最优解。

动态规划适用于问题具有**重叠子问题**和**最优子结构**的性质。它的核心在于找到问题的递推关系，并通过记忆化递归或自底向上的迭代来高效求解。



# 例题



### 1. **斐波那契数列**（简单）

> 题目描述：求第 `n` 个斐波那契数。斐波那契数列的定义为：
>
> - F(0) = 0, F(1) = 1
> - 对于 n ≥ 2，F(n) = F(n-1) + F(n-2)

> **要求：** 使用动态规划求解。

### 2. **爬楼梯问题**（简单）

> 题目描述：假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶？
>
> **输入：** `n = 3` **输出：** `3`
>
> **解释：**
>
> 1. 1 阶 + 1 阶 + 1 阶
> 2. 1 阶 + 2 阶
> 3. 2 阶 + 1 阶

### 3. **背包问题**（中等）

> 题目描述：有一个背包容量为 `W`，现在有 `n` 件物品，每件物品都有重量 `weight[i]` 和价值 `value[i]`，你需要在不超过背包容量的情况下，选取若干件物品，使得物品的总价值最大。
>
> **要求：** 使用动态规划解决。
>
> **输入：**
>
> - `weights = [2, 1, 3, 2]`
> - `values = [12, 10, 20, 15]`
> - `W = 5`
>
> **输出：** `37`

解决过程：

```
def leet_code():
    weights = [2, 1, 3, 2]
    values = [12, 10, 20, 15]
    W = 5
    res = solve(weights, values, W)
    print(res)

def solve(weights, values, W):
    """
    dp[j]=max(dp[j],dp[j−wi]+vi)
    问题就是分解成对于每个物品i，只有两种选择，1.你选它 那么此时重量和价值就要算上这个物品i的重量和价值 2.不选他 此时重量和价值就不需要算上物品i直接让i+1
    注意点：边界值
    """
    return dfs(weights, values, 0, 0, 0, W)

def dfs(weights, values, i, CV, CW, W):
    if i == len(weights):
        if CW > W:
            return CV - values[i - 1]
        return CV
    if CW == W:
        return CV
    if CW > W:
        return CV - values[i-1]
    return max(dfs(weights, values, i+1, CV+values[i], CW+weights[i], W), dfs(weights, values, i+1, CV, CW, W))


if __name__ == '__main__':
    leet_code()
```

### 4. **最长递增子序列**（中等）

> 题目描述：给定一个无序的整数数组，找到其中最长递增子序列的长度。
>
> **输入：** `nums = [10, 9, 2, 5, 3, 7, 101, 18]` **输出：** `4`
>
> **解释：** 最长递增子序列是 `[2, 3, 7, 101]`，长度为 4。

### 5. **最小路径和**（中等）

> 题目描述：给定一个 `m x n` 的网格，其中每个格子包含一个非负整数，找到一条从左上角到右下角的路径，使得路径上的数字总和最小。每次只能向下或向右移动。
>
> **输入：**
>
> ```
> css复制代码grid = [  [1, 3, 1],
>   [1, 5, 1],
>   [4, 2, 1]
> ]
> ```
>
> **输出：** `7` **解释：** 路径 1 → 3 → 1 → 1 → 1 总和为 7。

### 6. **零钱兑换问题**（中等）

> 题目描述：给定不同面额的硬币和一个总金额，写一个函数来计算可以凑成该总金额的最少硬币数。如果没有任何一种硬币组合能组成该金额，返回 `-1`。
>
> **输入：**
>
> - `coins = [1, 2, 5]`
> - `amount = 11`
>
> **输出：** `3` **解释：** 11 = 5 + 5 + 1

### 7. **编辑距离**（困难）

> 题目描述：给定两个单词 `word1` 和 `word2`，计算将 `word1` 转换成 `word2` 所使用的最少操作数。你可以进行以下三种操作：
>
> - 插入一个字符
> - 删除一个字符
> - 替换一个字符
>
> **输入：**
>
> - `word1 = "horse"`
> - `word2 = "ros"`
>
> **输出：** `3`
>
> **解释：**
>
> - horse → rorse (替换 'h' 为 'r')
> - rorse → rose (删除 'r')
> - rose → ros (删除 'e')

### 8. **正则表达式匹配**（困难）

> 题目描述：给你一个字符串 `s` 和一个字符模式 `p`，实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。
>
> - `'.'` 匹配任意单个字符。
> - `'*'` 匹配零个或多个前面的那一个元素。
>
> **输入：**
>
> - `s = "aab"`
> - `p = "c*a*b"`
>
> **输出：** `true`

这些问题涵盖了从简单到困难的各种动态规划场景，非常适合逐步深入理解动态规划思想。你可以先尝试其中的几道题，碰到困难的话随时来问！